{"name":"JSS","tagline":"Javascript Style Sheet","body":"JSS - Javascript Style Sheet\r\n===\r\n\r\n# Introdução\r\n***\r\nJSS é um framework javascript, que trabalha com CSS. Seguindo o modelo já bem sucedido de outros frameworks como SASS e LESS, a JSS traz também a alternativas para se dar um maior poder ao CSS.\r\n## Diferencial\r\nA grande diferença da JSS em comparação aos outros frameworks, é que ela não introduz uma nova linguagem, e nem precisa de um compilador para gerar as folhas de estilo, é todo o poder do javascript agora escrevendo CSS de maneira simples e prática. Além disso, JSS introduz o conceito de tratamento de imagens, onde é possível utilizar de diversas funções para tratar as cores de uma imagem. Isso é muito eficiente para bibliotecas de ícones, é possível modificar a cor dos ícones com apenas alguns métodos.\r\n***\r\n## O Básico\r\nO objeto JSS principal, deve invocar a propriedade `init`, passando um objeto JSON que contenha toda a instrução:\r\n\r\n<!-- language: lang-js -->\r\n\tvar build = function(){\r\n\t\treturn new JSS({\r\n\t    \t\tinit: {\r\n\t      \t\t\t'#divID':{\r\n\t        \t\t\t'border': {\r\n\t\t\t  \t\t\t\t'&': '#ddd solid 1px',\r\n\t\t\t  \t\t\t\t'top':{\r\n\t\t\t    \t\t\t\t\t'left':{\r\n\t\t\t      \t\t\t\t\t\t'radius': 35\r\n\t\t\t    \t\t\t\t\t}\r\n\t\t\t  \t\t\t\t},\r\n\t\t\t\t  \t\t\t'bottom':{\r\n\t\t\t\t    \t\t\t\t'left':{\r\n\t\t\t\t      \t\t\t\t\t'radius': 35\r\n\t\t\t\t    \t\t\t\t}\r\n\t\t\t\t  \t\t\t}\r\n\t\t\t\t\t}\r\n\t      \t\t}\r\n\t    \t}\r\n\t  \t});\r\n\t}\r\n\r\nA propriedade `init` é que ficará responsável por fazer o parser do objeto JSON. Porem a maneira mais eficaz não é passar diretamente o objeto JSON no `init`, e sim criar uma objeto global com uma função de build e outra de style:\r\n\r\n\tvar CSS = {\r\n\t\t\r\n\t\tblack: '#000',\r\n\t\twhite: '#fff',\r\n\t\t\r\n\t\tstyle: function(){\r\n\t\t\t\r\n\t\t\t\r\n\t\t\treturn {\r\n\t\t\t\t'.super-head': {\r\n\t\t\t\t\t'background': '#-linear-gradient(top, \\\r\n\t\t\t\t\t\t\t\t\t'+JSS.Ligthen(this.black, 20).alpha(.8)+' 0%, \\\r\n\t\t\t\t\t\t\t\t\t'+JSS.Ligthen(this.black, 50).alpha(0)+' 100%)',\r\n\t\t\t\t\t'height': 200,\r\n\t\t\t\t\t'width': '100%',\r\n\t\t\t\t\t'overflow': 'hidden',\r\n\t\t\t\t\t'& > header':{\r\n\t\t\t\t\t\t'& > img':{\r\n\t\t\t\t\t\t\t'position': 'absolute',\r\n\t\t\t\t\t\t\t'left': 'calc(100% - 254px)',\r\n\t\t\t\t\t\t\t'z-index': '100',\r\n\t\t\t\t\t\t\t'top': 10,\r\n\t\t\t\t\t\t\t'background': this.white,\r\n\t\t\t\t\t\t\t'padding-left': 10,\r\n\t\t\t\t\t\t\t'border': {\r\n\t\t\t\t\t\t\t\t'&': '#ddd solid 1px',\r\n\t\t\t\t\t\t\t\t'top':{\r\n\t\t\t\t\t\t\t\t\t'left':{\r\n\t\t\t\t\t\t\t\t\t\t'radius': 35\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t'bottom':{\r\n\t\t\t\t\t\t\t\t\t'left':{\r\n\t\t\t\t\t\t\t\t\t\t'radius': 35\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t'box-shadow': '#333 3px 5px 3px',\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tbuild: function(){\r\n\t\t\treturn new JSS({\r\n\t\t\t\tinit: this.style()\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n  \tCSS.build();\r\n\r\nDessa maneira é possível criar propriedades no objeto CSS e chama-las no método style por meio do scopo local `this`.\r\n\r\n## Seletores e propriedades aninhadas\r\nEm JSS tanto os seletores quanto as propriedades podem ser aninhadas. Para seletores é usado o caractere `&` para aninha-los, já com as propriedades não é necessário:\r\n<!-- language: lang-js -->\r\n    'table':{\r\n\t\t'& tr':{\r\n\t\t\t'padding':{\r\n\t\t\t\t'top': 5,\r\n\t\t\t\t'bottom': 5\r\n\t\t\t},\r\n\t\t\t'& td':{\r\n\t\t\t\t'&(1)':{\t\r\n\t\t\t\t\t'font-weight': 'bold'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t'border': {\r\n\t\t\t'&': '#ccc solid 1px',\r\n\t\t\t'radius': 5\r\n\t\t}\r\n\t}\r\n\t/*\r\n\t * Saida:\r\n\t * table {\r\n\t * \tborder: '#ccc solid 1px';\r\n\t * \tborder-radius: 5px;\r\n\t * }\r\n\t * \r\n\t * table tr {\r\n\t * \tpadding-top: 5px;\r\n\t * \tpadding-bottom: 5px;\r\n\t * }\r\n\t * \r\n\t * table tr td:nth-child(1){\r\n\t * \tfont-weight: bold;\r\n\t * }\r\n\t */\r\nÉ importante entender como é feito o parser dos objetos em JSS, todo aninhamento, seja ele de seletor ou de propriedade, é feito por meio de concatenação de strings, dessa forma deve se entender onde e quando aplicar espaços ou não após o `&`. Veja o exemplo a seguir:\r\n\r\n<!-- language: lang-js -->\r\n\t'table':{\r\n\t\t'&tr':{\r\n\t\t\t...\r\n\t\t}\r\n\t}\r\nObservem que o seletor aninhado `&tr` não tem espaço após o `&`, isso geraria um seletor `tabletr{...}` que não representaria a real intenção do usuário. Para que a JSS gerasse um seletor corretamente, deve-se aplicar o espaço após o `&` dessa maneira `& tr` concatenaria com `table` dessa forma: `\"table\"+\" tr\"`, que dessa vez geraria o seletor esperado: `table tr{...}`.\r\nEm propriedades, o uso do caracter `&` sozinho, faz com que o valor passado se aplique à propriedade a cima de forma única. No exemplo\r\n\r\n<!-- language: lang-js -->\r\n\t'border': {\r\n\t\t'&': '#ccc solid 1px'\r\n\t}\r\nGera a saída: `border: #ccc solid 1px`.\r\n\r\n<!-- language: lang-js -->\r\n\t'border': {\r\n\t\t'radius': 5\r\n\t}\r\nGera a saída: `border-radius: 5px`\r\n\r\nTodo inteiro passado como valor é convertido para a unidade de pexel `px`, dessa maneira o exemplo a cima `'radius': 5` é convertido em `5px`, para unidades diferentes é necessario que se passe o valor por string: `'radius': '1em'`. em propriedades que não são relacionadas a medida, como é o caso da propriedade `z-index` o valor desse explicitamente ser passado por string, para que não seja convertido em `px`, dessa forma `'z-index': '2'` é convertido da maneira esperada.\r\n\r\n## Funções\r\n\r\nEm JSS, também é possivel importar funções para seu objeto de estilo principal por meio da propriedade `'$import': [this.func()]`, as funções devem retornar um objeto JSON de estilo ou um array de objetos.\r\n\r\n<!-- language: lang-js -->\r\n\tbordaJanela: function(rounded, shadow){\r\n\t\tvar estilo = [];\r\n\t\t\r\n\t\tif(rounded === true){\r\n\t\t\testilo.push({'border-radius': 5});\r\n\t\t}\r\n\t\tif(shadow === true){\r\n\t\t\testilo.push({'box-shadow': '#000 3px 3px 5px'});\r\n\t\t}\r\n\t\t\r\n\t\treturn estilo;\r\n\t\t\r\n\t},\r\n\t\r\n\tstyle: function(){\r\n\t\treturn {\r\n\t\t\t'.window':{\r\n\t\t\t\t'$import': [this.bordaJanela(true, true)]\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\nMais de uma função também pode ser chamada por `$import` pasando o array: `'$import': [this.func1(), this.func2, ...]`.\r\n\r\n## Cores\r\n\r\nA Subclasse `JSS.Color` traz diversas funções para manipulação de cores, para usar a classe JSS.Color é preciso inicia-la passando uma cor ao construtor, com qualquer formato de cor aceita pela CSS.\r\n\r\n<!-- language: lang-js -->\r\n\tnew JSS.Color(\"red\");\r\n\tnew JSS.Color(\"#f00\");\r\n\tnew JSS.Color(\"#ff0000\");\r\n\tnew JSS.Color(\"rgb(255,0,0)\");\r\n\tnew JSS.Color(\"rgba(255,0,0,1)\");\r\n\tnew JSS.Color(\"hsl(0,100,50)\");\r\n\tnew JSS.Color(\"hsla(0,100,50,1)\");\r\n\t\r\nTodos os formatos a cima resultam na cor vermelha. Após o objeto criado, é possível manipular todos os canais de cores, mesmo que não corresponda ao formato original.\r\n\r\n<!-- language: lang-js -->\r\n\tvar vermelho = new JSS.Color(\"red\");\r\n\tvermelho.hue(20).green(30).saturation(20).alpha(.4).ligth(10).blue(20);\r\n\t\r\nOutras funções que de manipulação de cor também podem ser aplicadas\r\n\r\n<!-- language: lang-js -->\r\n\tvar vermelho = new JSS.Color(\"red\");\r\n\tvermelho.desaturation(20).dark(20).multiply(\"blue\").screen(\"#527\").overlay(\"rgb(23,53,132)\").mix(vermelho, 20);\r\n\t\r\nTambém é possivel utilizar o método `getDistance(color)` da CLasse `JSS.Color`, que retornará um valor representado a qual diferente(distante) uma cor é da outra.\r\n\r\n<!-- language: lang-js -->\r\n\tvar vermelho = new JSS.Color(\"red\");\r\n\tvermelho.getDistance(\"blue\"); // Que resultará no valor 360.62445840513925;\r\n\tvermelho.getDistance(\"red\");  // Que resultará no valor 0;\r\n\t\r\nTambém é possivel iniciar as cores pelos metodos staticos.\r\n\r\n<!-- language: lang-js -->\r\n\tvar vermelho = JSS.Ligthen(\"red\", 30);\r\n\t// E depois se quiser ainda poderá continuar a mexer em seus canais.\r\n\tvermelho.alpha(.3);\r\n\t// Ou pela forma abreviada.\r\n\tJSS.Ligthen(\"red\", 30).alpha(.3);\r\n\t\r\nAs funções estaticas de Cores são:\r\n\r\n<!-- language: lang-js -->\r\n\tJSS.Ligthen(color, percentLigth);\r\n\tJSS.Darken(color, percentDark);\r\n\tJSS.GetDistanceColor(color1, color2);\r\n\tJSS.Mix(color1, color2, weight);\r\n\tJSS.Multiply(color1, color2);\r\n\tJSS.SCreen(color1, color2);\r\n\tJSS.Overlay(color1, color2);\r\n\tJSS.Defference(color1, color2);\r\n\tJSS.Saturate(color, percent);\r\n\tJSS.Desaturate(color, percent);\r\n\t\r\n# CSS Hack\r\n\r\nAo adicionar os caracteres `#-` ao inicio de uma propriedade ou valor, JSS interpretará esses caracteres como um CSS hack, como no exemplo a seguir:\r\n\r\n<!-- language: lang-js -->\r\n\t'.gradient': {\r\n\t\t'background': '#-linear-gradient(top, \\\r\n\t\t\t\t\t\t'+JSS.Ligthen(this.black, 20).alpha(.8)+' 0%, \\\r\n\t\t\t\t\t\t'+JSS.Ligthen(this.black, 50).alpha(0)+' 100%)',\r\n\t}\r\n\t\r\nSaida:\r\n\r\n<!-- language: lang-css -->\r\n\t.gradient {\r\n\t\tbackground: linear-gradient(top, rgba(51,51,51,0.8) 0%, rgba(128,128,128,0) 100%);\r\n\t\tbackground: -o-linear-gradient(top, rgba(51,51,51,0.8) 0%, rgba(128,128,128,0) 100%);\r\n\t\tbackground: -ms-linear-gradient(top, rgba(51,51,51,0.8) 0%, rgba(128,128,128,0) 100%);\r\n\t\tbackground: -moz-linear-gradient(top, rgba(51,51,51,0.8) 0%, rgba(128,128,128,0) 100%);\r\n\t\tbackground: -khtml-linear-gradient(top, rgba(51,51,51,0.8) 0%, rgba(128,128,128,0) 100%);\r\n\t\tbackground: -webkit-linear-gradient(top, rgba(51,51,51,0.8) 0%, rgba(128,128,128,0) 100%);\r\n\t}\r\n\t\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}